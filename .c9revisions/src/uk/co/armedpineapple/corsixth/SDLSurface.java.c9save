{"ts":1354184466743,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n *   Copyright (C) 2012 Alan Woolley\n *   \n *   See LICENSE.TXT for full license\n */\npackage uk.co.armedpineapple.corsixth;\n\nimport uk.co.armedpineapple.corsixth.gestures.LongPressGesture;\nimport uk.co.armedpineapple.corsixth.gestures.TwoFingerMoveGesture;\n\nimport android.graphics.Canvas;\nimport android.graphics.PixelFormat;\nimport android.hardware.Sensor;\nimport android.hardware.SensorEvent;\nimport android.hardware.SensorEventListener;\nimport android.hardware.SensorManager;\nimport android.util.Log;\nimport android.view.GestureDetector;\nimport android.view.KeyEvent;\nimport android.view.MotionEvent;\nimport android.view.ScaleGestureDetector;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\nimport android.view.View;\n\n/**\n * SDLSurface. This is what we draw on, so we need to know when it's created in\n * order to do anything useful.\n * \n * Because of this, that's where we set up the SDL thread\n */\npublic class SDLSurface extends SurfaceView implements SurfaceHolder.Callback,\n\t\tView.OnKeyListener, View.OnTouchListener, SensorEventListener {\n\n\tpublic int\t\t\t\t\t\t\t\t\t\twidth, height;\n\n\t// Sensors\n\tprivate static SensorManager\tmSensorManager;\n\n\tprivate GestureDetector\t\t\t\tlongPressGestureDetector;\n\tprivate ScaleGestureDetector\tmoveGestureDetector;\n\n\tprivate SDLActivity\t\t\t\t\t\tcontext;\n\n\t// Startup\n\tpublic SDLSurface(SDLActivity context, int width, int height) {\n\t\tsuper(context);\n\t\tthis.context = context;\n\t\tgetHolder().addCallback(this);\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tsetFocusable(true);\n\t\tsetFocusableInTouchMode(true);\n\t\trequestFocus();\n\t\tsetOnKeyListener(this);\n\t\tsetOnTouchListener(this);\n\t\tmoveGestureDetector = new ScaleGestureDetector(context,\n\t\t\t\tnew TwoFingerMoveGesture());\n\t\tlongPressGestureDetector = new GestureDetector(context,\n\t\t\t\tnew LongPressGesture());\n\t\tlongPressGestureDetector.setIsLongpressEnabled(true);\n\n\t\tmSensorManager = (SensorManager) context.getSystemService(\"sensor\");\n\n\t}\n\n\t// Called when we have a valid drawing surface\n\tpublic void surfaceCreated(SurfaceHolder holder) {\n\t\tLog.v(getClass().getSimpleName(), \"surfaceCreated()\");\n\n\t\tSDLActivity.createEGLSurface();\n\n\t\tenableSensor(Sensor.TYPE_ACCELEROMETER, true);\n\t}\n\n\t// Called when we lose the surface\n\tpublic void surfaceDestroyed(SurfaceHolder holder) {\n\t\tLog.v(getClass().getSimpleName(), \"surfaceDestroyed()\");\n\n\t\t// Send a quit message to the application\n\t\t// SDLActivity.nativePause();\n\t\tSDLActivity.nativeQuit();\n\n\t\tenableSensor(Sensor.TYPE_ACCELEROMETER, false);\n\n\t}\n\n\t// Called when the surface is resized\n\tpublic void surfaceChanged(SurfaceHolder holder, int format, int width,\n\t\t\tint height) {\n\t\tLog.d(getClass().getSimpleName(), \"surfaceChanged()\");\n\n\t\tint sdlFormat = 0x85151002; // SDL_PIXELFORMAT_RGB565 by default\n\t\tswitch (format) {\n\t\t\tcase PixelFormat.A_8:\n\t\t\t\tLog.v(SDLActivity.class.getSimpleName(), \"pixel format A_8\");\n\t\t\t\tbreak;\n\t\t\tcase PixelFormat.L_8:\n\t\t\t\tLog.v(SDLActivity.class.getSimpleName(), \"pixel format L_8\");\n\t\t\t\tbreak;\n\t\t\tcase PixelFormat.RGBA_8888:\n\t\t\t\tLog.v(SDLActivity.class.getSimpleName(), \"pixel format RGBA_8888\");\n\t\t\t\tsdlFormat = 0x86462004; // SDL_PIXELFORMAT_RGBA8888\n\t\t\t\tbreak;\n\t\t\tcase PixelFormat.RGBX_8888:\n\t\t\t\tLog.v(SDLActivity.class.getSimpleName(), \"pixel format RGBX_8888\");\n\t\t\t\tsdlFormat = 0x86262004; // SDL_PIXELFORMAT_RGBX8888\n\t\t\t\tbreak;\n\t\t\tcase PixelFormat.RGB_565:\n\t\t\t\tLog.v(SDLActivity.class.getSimpleName(), \"pixel format RGB_565\");\n\t\t\t\tsdlFormat = 0x85151002; // SDL_PIXELFORMAT_RGB565\n\t\t\t\tbreak;\n\t\t\tcase PixelFormat.RGB_888:\n\t\t\t\tLog.v(SDLActivity.class.getSimpleName(), \"pixel format RGB_888\");\n\t\t\t\t// Not sure this is right, maybe SDL_PIXELFORMAT_RGB24 instead?\n\t\t\t\tsdlFormat = 0x86161804; // SDL_PIXELFORMAT_RGB888\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLog.v(SDLActivity.class.getSimpleName(), \"pixel format unknown \"\n\t\t\t\t\t\t+ format);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tSDLActivity.onNativeResize(width, height, sdlFormat);\n\n\t\tcontext.startApp();\n\n\t}\n\n\t// unused\n\tpublic void onDraw(Canvas canvas) {\n\t}\n\n\t// Key events\n\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\tswitch (keyCode) {\n\t\t\tcase KeyEvent.KEYCODE_VOLUME_DOWN:\n\t\t\t\treturn false;\n\t\t\tcase KeyEvent.KEYCODE_VOLUME_UP:\n\t\t\t\treturn false;\n\t\t\tcase KeyEvent.KEYCODE_VOLUME_MUTE:\n\t\t\t\treturn false;\n\t\t\tcase KeyEvent.KEYCODE_MENU:\n\t\t\t\treturn false;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tif (event.getAction() == KeyEvent.ACTION_DOWN) {\n\t\t\tSDLActivity.onNativeKeyDown(keyCode);\n\t\t\treturn true;\n\t\t} else if (event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\tSDLActivity.onNativeKeyUp(keyCode);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Triggered when the screen is touched. We need to convert the location\n\t * pressed on the display into a location on the surface. As this is not\n\t * always 1:1 (when not using native resolution), we need to do a bit of\n\t * maths.\n\t */\n\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t// Forward event to the gesture detector.\n\t\tlongPressGestureDetector.onTouchEvent(event);\n\n\t\tmoveGestureDetector.onTouchEvent(event);\n\t\tfinal int pointerCount = event.getPointerCount();\n\n\t\tif (!moveGestureDetector.isInProgress() && pointerCount < 2) {\n\t\t\tfinal int touchDevId = event.getDeviceId();\n\t\t\tint actionPointerIndex = event.getActionIndex();\n\t\t\tint pointerFingerId = event.getPointerId(actionPointerIndex);\n\n\t\t\tint action = event.getAction();\n\n\t\t\tfloat[] coords = translateCoords(event.getX(actionPointerIndex),\n\t\t\t\t\tevent.getY(actionPointerIndex));\n\t\t\tfloat p = event.getPressure(actionPointerIndex);\n\n\t\t\tif (action == MotionEvent.ACTION_MOVE && pointerCount == 1) {\n\t\t\t\t// TODO send motion to every pointer if its position has\n\t\t\t\t// changed since prev event.\n\t\t\t\tfor (int i = 0; i < pointerCount; i++) {\n\t\t\t\t\tpointerFingerId = event.getPointerId(i);\n\t\t\t\t\tcoords = translateCoords(event.getX(actionPointerIndex),\n\t\t\t\t\t\t\tevent.getY(actionPointerIndex));\n\t\t\t\t\tp = event.getPressure(i);\n\t\t\t\t\tSDLActivity.onNativeTouch(touchDevId, pointerFingerId, action,\n\t\t\t\t\t\t\tcoords[0], coords[1], p, pointerCount, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSDLActivity.onNativeTouch(touchDevId, pointerFingerId, action,\n\t\t\t\t\t\tcoords[0], coords[1], p, pointerCount, 0);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic float[] translateCoords(float x, float y) {\n\t\tfloat newX = ((float) this.width / getWidth()) * x;\n\t\tfloat newY = ((float) this.height / getHeight()) * y;\n\t\treturn new float[] { newX, newY };\n\t}\n\n\t// Sensor events\n\tpublic void enableSensor(int sensortype, boolean enabled) {\n\t\t// TODO: This uses getDefaultSensor - what if we have >1 accels?\n\t\tif (enabled) {\n\t\t\tmSensorManager.registerListener(this,\n\t\t\t\t\tmSensorManager.getDefaultSensor(sensortype),\n\t\t\t\t\tSensorManager.SENSOR_DELAY_GAME, null);\n\t\t} else {\n\t\t\tmSensorManager.unregisterListener(this,\n\t\t\t\t\tmSensorManager.getDefaultSensor(sensortype));\n\t\t}\n\t}\n\n\tpublic void onAccuracyChanged(Sensor sensor, int accuracy) {\n\t\t// TODO\n\t}\n\n\tpublic void onSensorChanged(SensorEvent event) {\n\t\tif (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {\n\t\t\tSDLActivity.onNativeAccel(event.values[0] / SensorManager.GRAVITY_EARTH,\n\t\t\t\t\tevent.values[1] / SensorManager.GRAVITY_EARTH, event.values[2]\n\t\t\t\t\t\t\t/ SensorManager.GRAVITY_EARTH);\n\t\t}\n\t}\n}"]],"start1":0,"start2":0,"length1":0,"length2":7118}]],"length":7118}
{"contributors":[],"silentsave":false,"ts":1354184598303,"patch":[[{"diffs":[[0,"n true;\n\t}\n\n"],[1,"    /**\n     * Translates an x,y pair of coordinates according to the scaling factor\n     * of the surface\n     * \n     * @return an array containing the translated coordinates\n     */\n"],[0,"\tpublic floa"]],"start1":6113,"start2":6113,"length1":24,"length2":209}]],"length":7303,"saved":false}
