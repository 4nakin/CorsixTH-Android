{"ts":1354184255165,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n *   Copyright (C) 2012 Alan Woolley\n *   \n *   See LICENSE.TXT for full license\n */\npackage uk.co.armedpineapple.corsixth;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport com.bugsense.trace.BugSenseHandler;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.content.res.AssetManager;\nimport android.os.AsyncTask;\nimport android.os.Environment;\nimport android.os.PowerManager;\nimport android.os.PowerManager.WakeLock;\nimport android.util.Log;\n\n/** Class to help with file manipulation */\n@SuppressWarnings(\"nls\")\npublic class Files {\n\n\t// Look for these files when trying to work out if the original Theme\n\t// Hospital files are present\n\n\tprivate static final String[]\tRequiredSoundFiles\t= { \"Sound/Data/Sound-0.dat\" };\n\n\tprivate static final String[]\tRequiredMusicFiles\t= { \"Sound/Midi/ATLANTIS.XMI\" };\n\tprivate static final String[]\tRequiredDataFiles\t\t= { \"Data/VBlk-0.tab\",\n\t\t\t\"Levels/Level.L1\", \"QData/SPointer.dat\"\t\t\t};\n\n\t// Places to look for files\n\t@SuppressLint(\"SdCardPath\")\n\tprivate static final String[]\tSearchRoot\t\t\t\t\t= { \"/mnt/sdcard\",\n\t\t\t\"/sdcard\", \"/mnt/sdcard/external_sd\", \"/mnt/emmc\", \"/mnt/sdcard/emmc\" };\n\n\tprivate static final String[]\tSearchDirs\t\t\t\t\t= { \"th\", \"TH\",\n\t\t\t\"themehospital\", \"ThemeHospital\", \"Themehospital\", \"theme_hospital\",\n\t\t\t\"Theme_Hospital\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\tprivate Files() {\n\t}\n\n\t/**\n\t * Checks if a file exists on the filesystem\n\t * \n\t * @param filename\n\t *          the file to check\n\t * @return true if file exists\n\t */\n\tpublic static Boolean doesFileExist(String filename) {\n\t\tFile f = new File(filename);\n\t\treturn f.exists();\n\t}\n\n\t/**\n\t * Removes path separators from the end of path strings\n\t * \n\t * @param path\n\t *          the path to trim\n\t * @return the trimmed path\n\t */\n\tpublic static String trimPath(String path) {\n\t\treturn path.endsWith(File.separator) ? path.substring(0, path.length() - 1)\n\t\t\t\t: path;\n\t}\n\n\tpublic static String getExtStoragePath() {\n\t\treturn trimPath(Environment.getExternalStorageDirectory().getAbsolutePath())\n\t\t\t\t+ File.separator;\n\t}\n\n\t/**\n\t * Checks if Theme Hospital data files exist in a directory\n\t * \n\t * @param directory\n\t *          the directory to search\n\t * @return true if data files exist\n\t */\n\tpublic static Boolean hasDataFiles(String directory) {\n\t\treturn doFilesExist(RequiredDataFiles, directory);\n\t}\n\n\t/**\n\t * Checks if Theme Hospital music files exist in a directory\n\t * \n\t * @param directory\n\t *          the directory to search\n\t * @return true if music files exist\n\t */\n\tpublic static Boolean hasMusicFiles(String directory) {\n\t\treturn doFilesExist(RequiredMusicFiles, directory);\n\t}\n\n\t/**\n\t * Checks if Theme Hospital sound files exist in a directory\n\t * \n\t * @param directory\n\t *          the directory to search\n\t * @return true if sound files exist\n\t */\n\tpublic static Boolean hasSoundFiles(String directory) {\n\t\treturn doFilesExist(RequiredSoundFiles, directory);\n\t}\n\n\t/**\n\t * Checks if all the given files exist in a given directory\n\t * \n\t * @param files\n\t *          an array of filenames to check for\n\t * @param directory\n\t *          the directory to search\n\t * @return true if all the files are found\n\t */\n\tprivate static Boolean doFilesExist(String[] files, String directory) {\n\t\t// Log.d(Files.class.getSimpleName(), \"Checking directory: \" +\n\t\t// directory);\n\n\t\tif (directory == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tFile dir = new File(directory);\n\t\tif (!dir.exists() || !dir.isDirectory()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// As soon as a file is not found in the directory, fail.\n\t\tfor (String file : files) {\n\t\t\tFile f = new File(directory + \"/\" + file);\n\t\t\tif (!f.exists()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if external storage can be accessed. This should be called any time\n\t * external storage is used to make sure that it is accessible. Reasons that\n\t * it may not be accessible include SD card missing, mounted on a computer,\n\t * not formatted etc.\n\t * \n\t * @return true if external storage can be accessed\n\t */\n\tpublic static boolean canAccessExternalStorage() {\n\t\treturn Environment.MEDIA_MOUNTED.equals(Environment\n\t\t\t\t.getExternalStorageState());\n\t}\n\n\t/**\n\t * Lists all the files in a directory. It will not list files in\n\t * subdirectories.\n\t * \n\t * @param directory\n\t *          the directory to search in\n\t * @param filter\n\t *          a {@link FilenameFilter} to filter the search by\n\t * @return a String array of filenames\n\t * @throws IOException\n\t *           if the directory doesn't exist or cannot be accessed\n\t */\n\tpublic static List<FileDetails> listFilesInDirectory(String directory,\n\t\t\tFilenameFilter filter) throws IOException {\n\t\t// Log.d(Files.class.getSimpleName(), \"Looking for files in: \" +\n\t\t// directory);\n\n\t\tFile f = new File(directory);\n\t\tList<FileDetails> files = new ArrayList<FileDetails>();\n\t\tif (f.isDirectory()) {\n\t\t\t// Log.d(Files.class.getSimpleName(), \"Directory \" + directory\n\t\t\t// + \" looks ok\");\n\n\t\t\tString[] filesArray = f.list(filter);\n\n\t\t\t// Log.d(Files.class.getSimpleName(), \"Found: \" + filesArray.length\n\t\t\t// + \" files\");\n\n\t\t\tfor (String fileName : filesArray) {\n\n\t\t\t\tFile file = new File(directory + File.separator + fileName);\n\t\t\t\tlong lastModified = file.lastModified();\n\t\t\t\tfiles.add(new FileDetails(fileName, new Date(lastModified)));\n\t\t\t}\n\n\t\t\treturn files;\n\t\t}\n\n\t\t// The directory doesn't exist\n\t\tLog.d(Files.class.getSimpleName(), \"Directory \" + directory\n\t\t\t\t+ \" doesn't exist\");\n\t\tthrow new FileNotFoundException();\n\n\t}\n\n\t/**\n\t * Returns a string containing the text from a raw resource\n\t * \n\t * @param ctx\n\t *          a context\n\t * @param resource\n\t *          the resource to read\n\t * @return a String containing the text contents of the resource\n\t * @throws IOException\n\t *           if the resource cannot be found or read\n\t */\n\tpublic static String readTextFromResource(Context ctx, int resource)\n\t\t\tthrows IOException {\n\t\t// TODO Probably a much nicer way to do this, with buffers.\n\t\tInputStream inputStream = ctx.getResources().openRawResource(resource);\n\n\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n\n\t\tint i;\n\n\t\ti = inputStream.read();\n\t\twhile (i != -1) {\n\t\t\tbyteArrayOutputStream.write(i);\n\t\t\ti = inputStream.read();\n\t\t}\n\t\tinputStream.close();\n\n\t\treturn byteArrayOutputStream.toString();\n\n\t}\n\n\t/**\n\t * {@link AsyncTask} for discovering all the assets included in the\n\t * application\n\t * */\n\tstatic class DiscoverAssetsTask extends\n\t\t\tAsyncTask<Void, Void, AsyncTaskResult<ArrayList<String>>> {\n\n\t\tArrayList<String>\tpaths;\n\t\tContext\t\t\t\t\t\tctx;\n\t\tString\t\t\t\t\t\tpath;\n\n\t\tDiscoverAssetsTask(Context ctx, String path) {\n\t\t\tthis.ctx = ctx;\n\t\t\tthis.path = path;\n\t\t}\n\n\t\t@Override\n\t\tprotected AsyncTaskResult<ArrayList<String>> doInBackground(Void... params) {\n\n\t\t\tpaths = new ArrayList<String>();\n\t\t\ttry {\n\t\t\t\tpaths = listAssets(ctx, path);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(Files.class.getSimpleName(),\n\t\t\t\t\t\t\"I/O Exception whilst listing files\", e);\n\t\t\t\tBugSenseHandler.sendException(e);\n\t\t\t\treturn new AsyncTaskResult<ArrayList<String>>(e);\n\n\t\t\t}\n\t\t\treturn new AsyncTaskResult<ArrayList<String>>(paths);\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link AsyncTask}syncTask for copying assets\n\t */\n\tstatic class CopyAssetsTask extends\n\t\t\tAsyncTask<ArrayList<String>, Integer, AsyncTaskResult<Void>> {\n\t\tWakeLock\tcopyLock;\n\t\tContext\t\tctx;\n\t\tString\t\troot, message;\n\n\t\tCopyAssetsTask(Context ctx, String root) {\n\t\t\tthis.ctx = ctx;\n\t\t\tthis.root = root;\n\n\t\t}\n\n\t\t@Override\n\t\tprotected void onPreExecute() {\n\t\t\tPowerManager pm = (PowerManager) ctx\n\t\t\t\t\t.getSystemService(Context.POWER_SERVICE);\n\t\t\tcopyLock = pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK, \"copying\");\n\t\t\tcopyLock.acquire();\n\t\t}\n\n\t\t@Override\n\t\tprotected AsyncTaskResult<Void> doInBackground(ArrayList<String>... params) {\n\t\t\tint max = params[0].size();\n\t\t\tfor (int i = 0; i < max; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tcopyAsset(ctx, params[0].get(i), root);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\treturn new AsyncTaskResult<Void>(e);\n\t\t\t\t}\n\t\t\t\tpublishProgress(i + 1, max);\n\t\t\t}\n\t\t\treturn new AsyncTaskResult<Void>((Void) null);\n\t\t}\n\n\t\t@Override\n\t\tprotected void onPostExecute(AsyncTaskResult<Void> result) {\n\t\t\tcopyLock.release();\n\t\t}\n\t}\n\n\t/**\n\t * Produces a list of assets in a directory\n\t * \n\t * @param ctx\n\t *          a context\n\t * @param path\n\t *          path to search in\n\t * @return a list of files\n\t * @throws IOException\n\t *           if the path doesn't exist, or asset can't be accessed\n\t */\n\tpublic static ArrayList<String> listAssets(Context ctx, String path)\n\t\t\tthrows IOException {\n\t\tArrayList<String> assets = new ArrayList<String>();\n\t\tlistAssetsInternal(ctx, path, assets);\n\t\treturn assets;\n\t}\n\n\tprivate static void listAssetsInternal(Context ctx, String path,\n\t\t\tArrayList<String> paths) throws IOException {\n\t\tAssetManager assetManager = ctx.getAssets();\n\t\tString assets[] = null;\n\n\t\tassets = assetManager.list(path);\n\n\t\tif (assets.length == 0) {\n\t\t\tpaths.add(path);\n\n\t\t} else {\n\t\t\tfor (int i = 0; i < assets.length; ++i) {\n\t\t\t\tlistAssetsInternal(ctx, path + \"/\" + assets[i], paths);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Copies an assets\n\t * \n\t * @param ctx\n\t *          a context\n\t * @param assetFilename\n\t *          the filename of the asset\n\t * @param destination\n\t *          the destination directory\n\t * @throws IOException\n\t *           if the asset cannot be copied\n\t */\n\tpublic static void copyAsset(Context ctx, String assetFilename,\n\t\t\tString destination) throws IOException {\n\t\tInputStream in = null;\n\t\tOutputStream out = null;\n\n\t\ttry {\n\t\t\tAssetManager assetManager = ctx.getAssets();\n\n\t\t\tin = assetManager.open(assetFilename);\n\n\t\t\tString newFileName = destination + \"/\" + assetFilename;\n\n\t\t\tFile dir = new File(newFileName).getParentFile();\n\t\t\tif (!dir.exists()) {\n\t\t\t\tdir.mkdirs();\n\t\t\t}\n\n\t\t\tout = new FileOutputStream(newFileName);\n\n\t\t\tLog.i(Files.class.getSimpleName(), \"Copying file [\" + assetFilename\n\t\t\t\t\t+ \"] to [\" + newFileName + \"]\");\n\n\t\t\tbyte[] buffer = new byte[1024];\n\t\t\tint read;\n\n\t\t\twhile ((read = in.read(buffer)) != -1) {\n\t\t\t\tout.write(buffer, 0, read);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (in != null) {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tif (out != null) {\n\t\t\t\tout.flush();\n\t\t\t\tout.close();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static class FindFilesTask extends\n\t\t\tAsyncTask<Void, Void, AsyncTaskResult<String>> {\n\n\t\t@Override\n\t\tprotected AsyncTaskResult<String> doInBackground(Void... arg0) {\n\t\t\treturn new AsyncTaskResult<String>(findGameFiles());\n\t\t}\n\n\t\tprivate String findGameFiles() {\n\t\t\tString result;\n\t\t\tList<String> searchPaths = new ArrayList<String>(\n\t\t\t\t\tArrays.asList(SearchRoot));\n\t\t\tString sdcard = trimPath(Environment.getExternalStorageDirectory()\n\t\t\t\t\t.getAbsolutePath());\n\n\t\t\tif (!searchPaths.contains(sdcard)) {\n\t\t\t\tsearchPaths.add(sdcard);\n\t\t\t}\n\n\t\t\t// Search common locations first\n\t\t\tfor (String root : searchPaths) {\n\t\t\t\tif (isCancelled()) {\n\t\t\t\t\tLog.d(Files.class.getSimpleName(), \"Task cancelled\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tfor (String dir : SearchDirs) {\n\t\t\t\t\tString toSearch = root + File.separator + dir;\n\t\t\t\t\tif ((result = findGameFilesInternal(toSearch)) != null) {\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (String root : searchPaths) {\n\t\t\t\tif (isCancelled()) {\n\t\t\t\t\tLog.d(Files.class.getSimpleName(), \"Task cancelled\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif ((result = findGameFilesInternal(root)) != null) {\n\t\t\t\t\tLog.d(Files.class.getSimpleName(), \"Found game files in: \" + result);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate String findGameFilesInternal(String root) {\n\t\t\tif (!isCancelled()) {\n\t\t\t\tString result;\n\t\t\t\tFile dir = new File(root);\n\n\t\t\t\tif (hasDataFiles(root)) {\n\t\t\t\t\treturn root;\n\t\t\t\t}\n\n\t\t\t\tif (dir.exists() && dir.isDirectory()) {\n\t\t\t\t\tFile[] sub = dir.listFiles();\n\t\t\t\t\tif (sub != null) {\n\t\t\t\t\t\tfor (File f : sub) {\n\t\t\t\t\t\t\tif (f.isDirectory()) {\n\t\t\t\t\t\t\t\tif ((result = findGameFilesInternal(trimPath(f\n\t\t\t\t\t\t\t\t\t\t.getAbsolutePath()))) != null) {\n\t\t\t\t\t\t\t\t\tLog.d(Files.class.getSimpleName(), \"Found game files in: \"\n\t\t\t\t\t\t\t\t\t\t\t+ result);\n\t\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLog.d(Files.class.getSimpleName(), \"Task cancelled\");\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\t/** AsyncTask for downloading a file */\n\tpublic static class DownloadFileTask extends\n\t\t\tAsyncTask<String, Integer, AsyncTaskResult<File>> {\n\t\tString\tdownloadTo;\n\n\t\tpublic DownloadFileTask(String downloadTo) {\n\t\t\tthis.downloadTo = downloadTo;\n\t\t}\n\n\t\t@Override\n\t\tprotected AsyncTaskResult<File> doInBackground(String... url) {\n\t\t\tURL downloadUrl;\n\t\t\tURLConnection ucon;\n\n\t\t\ttry {\n\t\t\t\tdownloadUrl = new URL(url[0]);\n\n\t\t\t\tFile file = new File(downloadTo + \"/\" + downloadUrl.getFile());\n\t\t\t\tfile.getParentFile().mkdirs();\n\n\t\t\t\tucon = downloadUrl.openConnection();\n\t\t\t\tucon.connect();\n\t\t\t\tint fileSize = ucon.getContentLength();\n\n\t\t\t\tInputStream input = new BufferedInputStream(downloadUrl.openStream());\n\t\t\t\tFileOutputStream fos = new FileOutputStream(file);\n\n\t\t\t\tbyte data[] = new byte[1024];\n\t\t\t\tint current = 0, total = 0;\n\n\t\t\t\twhile ((current = input.read(data)) != -1) {\n\t\t\t\t\ttotal += current;\n\t\t\t\t\tpublishProgress(total * 100 / fileSize);\n\n\t\t\t\t\tfos.write(data, 0, current);\n\t\t\t\t}\n\n\t\t\t\tfos.flush();\n\t\t\t\tfos.close();\n\t\t\t\tinput.close();\n\n\t\t\t\tLog.d(Files.class.getSimpleName(),\n\t\t\t\t\t\t\"Downloaded file to: \" + file.getAbsolutePath());\n\t\t\t\treturn new AsyncTaskResult<File>(file);\n\n\t\t\t} catch (MalformedURLException e) {\n\t\t\t\treturn new AsyncTaskResult<File>(e);\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn new AsyncTaskResult<File>(e);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/** AsyncTask for extracting a .zip file to a directory */\n\tpublic static class UnzipTask extends\n\t\t\tAsyncTask<File, Integer, AsyncTaskResult<String>> {\n\t\tString\tunzipTo;\n\n\t\tpublic UnzipTask(String unzipTo) {\n\t\t\tthis.unzipTo = unzipTo;\n\t\t}\n\n\t\t@Override\n\t\tprotected AsyncTaskResult<String> doInBackground(File... files) {\n\t\t\ttry {\n\n\t\t\t\tFile to = new File(unzipTo);\n\t\t\t\tto.mkdirs();\n\n\t\t\t\tZipFile zf = new ZipFile(files[0]);\n\t\t\t\tint entryCount = zf.size();\n\n\t\t\t\tEnumeration<? extends ZipEntry> entries = zf.entries();\n\t\t\t\tint count = 0;\n\n\t\t\t\twhile (entries.hasMoreElements()) {\n\t\t\t\t\tZipEntry ze = entries.nextElement();\n\t\t\t\t\tLog.v(Files.class.getSimpleName(), \"Unzipping \" + ze.getName());\n\n\t\t\t\t\tFile f = new File(unzipTo + ze.getName());\n\t\t\t\t\tif (!f.getParentFile().exists()) {\n\t\t\t\t\t\tf.getParentFile().mkdirs();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ze.isDirectory()) {\n\n\t\t\t\t\t\tif (!f.isDirectory()) {\n\t\t\t\t\t\t\tf.mkdirs();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tInputStream zin = zf.getInputStream(ze);\n\n\t\t\t\t\t\tFileOutputStream fout = new FileOutputStream(unzipTo + ze.getName());\n\n\t\t\t\t\t\tbyte[] buffer = new byte[1024];\n\t\t\t\t\t\tint read;\n\n\t\t\t\t\t\twhile ((read = zin.read(buffer)) != -1) {\n\t\t\t\t\t\t\tfout.write(buffer, 0, read);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tzin.close();\n\t\t\t\t\t\tfout.close();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcount++;\n\t\t\t\t\tpublishProgress(count * 100 / entryCount);\n\n\t\t\t\t}\n\n\t\t\t} catch (IOException e) {\n\t\t\t\tBugSenseHandler.sendException(e);\n\t\t\t\treturn new AsyncTaskResult<String>(e);\n\t\t\t}\n\n\t\t\treturn new AsyncTaskResult<String>(unzipTo);\n\n\t\t}\n\t}\n\n\tpublic static class FileDetails implements Comparable<FileDetails> {\n\n\t\tprivate Date\t\tlastModified;\n\t\tprivate String\tfileName;\n\n\t\tpublic FileDetails(String filename, Date lastModified) {\n\t\t\tthis.fileName = filename;\n\t\t\tthis.lastModified = lastModified;\n\t\t}\n\n\t\tpublic Date getLastModified() {\n\t\t\treturn lastModified;\n\t\t}\n\n\t\tpublic String getFileName() {\n\t\t\treturn fileName;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(FileDetails another) {\n\t\t\tif (lastModified.equals(another.getLastModified())) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn lastModified.after(another.getLastModified()) ? 1 : -1;\n\n\t\t}\n\t}\n\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":16004}]],"length":16004}
{"contributors":[],"silentsave":false,"ts":1354184282280,"patch":[[{"diffs":[[0," String\t"],[1,"    "],[0,"fileName"]],"start1":15523,"start2":15523,"length1":16,"length2":20}]],"length":16008,"saved":false}
{"contributors":[],"silentsave":false,"ts":1354184423682,"patch":[[{"diffs":[[0,": path;\n\t}\n\n"],[1,"    /**\n     * Gets the external storage path including a trailing file separator.\n     * \n     * @return the external storage path\n     */\n"],[0,"\tpublic stat"]],"start1":2415,"start2":2415,"length1":24,"length2":164}]],"length":16148,"saved":false}
